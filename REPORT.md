| Лабораторная работа №3 | M3102 | АОВС |
| ---------------------- | ----------- | ---- |
| Кэш и кодирование команд   | Алехина Ксения Степановна       | 2024 |



## Что реализовано
Вариант 1
Полная версия работы

## Результат работы на тестовых данных: [https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-kaleh1na/actions/runs/9070756707]()

# Описание:

# ISA
## Перевод кода задачи из C в ассемблер

Для начала, посчитаем адреса начала массивов. Они лежат последовательно, массив а начинается с адреса 0x100 - 256 в десятичке. Значит он занимает байты с 256 до 256 + M * K = 2304. Тогда 2304 - адрес начала b. Он, в свою очередь, лежит с 2304 до 2304 + M * N * 2 = 6144(домножили еще на 2, так как в массиве b лежат int16_t - они занимают 16 битов, а значит 2 байта). 6144 - адрес начала с.

Эти адресы понадобятся нам при работе с указателями. Так же нам нужно знать, как работают строки по типу pc += N и тд. Здесь мы прибавляем число к указателю, то есть фактическое число равное адресу под этими указателями увеличивается не на N, а на N * sizeof того, что под ним лежит. В случае массива c - это 4, массива b - это 2, массива с - это 1.

Из интересных фактов - данная функция отражает умножение матриц.

Теперь мы готовы переводить на ассемблер. Структурно все происходит так - у нас есть 32 регистра для записи. Некоторые из них выражают особые случаи - zero всегда содержит в себе 0, ra нужен для возвращения по адресу и т.д. В остальные же мы можем спокойно записывать. Также эти регистры делятся, например, на временные и сохраняющиеся, но в случае данной программы это не имеет значения.

Так же у нас есть инструкции. Структурно, они часто, выглядят так: Inst rd rs1 rs2, либо например Inst rd rs1 imm, могут выглядеть и по другому. Первым в строке всегда идет название команды, далее зависит от самой команды. Rd, rs1, rs2 - названия регистров, rd - всегда то, в какой регистр мы записываем результат, imm - число. 

Для итерации по циклам используются B. команды. В данном случае будем использовать BLT(less than). В случае true, такие команды перемещают нас на imm / 4 команд вперед или назад(если imm - отрицательное). Imm в таком случае обязательно кратно четырем, так как вся инструкция кодируется четырьмя байтами. То есть, для того чтобы итерироваться по циклу for (int i = 0; i < n; ++i), создаем переменную i = 0, по которой итерируемся, после выполнения тела цикла инкрементируем ее, и пока меньше чем n, возвращаемся на какое то количество инструкций назад(это количество надо честно посчитать так, чтобы мы переходили в начало тела цикла, и умножить на 4)

Так же разберемся с Load и Store командами, они обращаются к памяти и имеют такую структуру: L. rd imm rs1 - загружает в rd Mem[rs1 + imm] - если команда LB(загружает байт), если LH(загружает 2 байта) - то же самое, только 2 байта начиная с этого адреса. LW - 4 байта.

Store имеет такую струтуру: S. rs2 imm rs1: загружает rs2 по началу адреса rs1 + imm.

На это, собственно все. Далее просто аккуратно переписываем нужные вышеописанные инструкции по коду задачи.
## Перевод ассемблера в машинный код

### Парсинг
Для начала, нам нужно распарсить код на ассемблере. Все инструкции после парсинга сохраняются в вектор инструкций, лежащий в основном классе **CacheModel**

Определим две вспомогательные мапы:
-  **CommandId** - позволяет перейти от названий команд к индексам
-  **RegId** - позволяет перейти от названий регистров к индексам

Структура **Instruction** нужна для того чтобы хранить информацию об инструкции - в ней лежат индексы регистров, с которыми мы работаем, Immediate(число, если нужно для команды), id команды(полученное из мапы CommandId по названию команды), а так же ее тип

Существует 5 основных типов команд: R, I, B, S, U(также есть J, но отнесем их к U). Для удобства, Load команды были выделены в отдельный тип L, а команды ebreak и ecall в отдельный тип Е.

Это разделение нужно, во-первых, для самого кодирования: команды одного типа кодируются одинаково(кроме исключительных случаев), во-вторых, для парсинга - некоторые типы команд всегда идут с 3 аргументами, некоторые идут с числом, некоторые с двумя аргументами, а некоторые(тип Е) без аргументов. 

Поэтому, всегда будем парсить так: парсить первое слово в строке, создавать по нему Instruction, в конструкторе которой по названию команды определится ее id и тип, а после, в зависимости от типа, парсить дальше. В конце добавляем полученную иснтрукцию в вектор инструкций **program**

> Так как ассемблер регистронезависимый, все прописные буквы меняем на строчные

### Кодирование

Для кодирования нам так же понадобятся 3 вспомогательных вектора: **opcode** - по индексу команды лежит ее 7-битный опкод, нужный для кодирования, **funct3** - по индексу команды лежит ee 3-битный код, а также **funct7** - нужен только для R-типа - по индексу R-команды лежит ее 7-битный код.

Далее, кодирование зависит от типа команды. Из основных правил - кодируются 32 бита. Индексы регистров кодируются пятью битами(так как у нас есть 32 регистра). funct3 всегда лежит на бите от 14 до 12, opcode всегда лежит на битах от 6 до 0. Если у команды есть rs2 - он лежит на битах от 24 до 20, rs1 - на битах от 19 до 15, rd - на битах от 11 до 7. 

Далее идут разветвления. Например, immediate в I-типах хранит свои младшие 12 битов в битах от 31 до 25, а S-типы дробят immediate на 2 части по 7 битов в начале и 5 битов на месте rd. Здесь ориентируемся по памятке и аккуратно учитываем эти разветвления.

Структурно все происходит так: в методе **Code** класса CacheModel мы проходимся по вектору инструкций, у каждой инструкции вызываем метод кодирования **Code**, который берет данные либо из самой этой инструкции(тип команды, id команды, индексы регистров, immediate), либо из вспомогательных векторов по id команды(opcode, funct3, funct7), и в зависимости от ее типа и индекса кодирует, а мы записываем результат в файл в порядке little-endian(сначала младшие байты).

# Cache

## Расчет параметров системы

|Константа|Величина|Вычисление|
|-|-|-|
|MEM_SIZE| 262144 Б|1. длина адреса - 18 бит, значит фактический размер памяти равен 2^18 = 2612144|
|ADDR_LEN|18 бит| дано|
|CACHE_WAY|4|дано|
|CACHE_TAG_LEN|8|6. длина индекса тега равна разнице длины адреса с суммой длины индекса блока и длины оффсета, т.е 18 - 5 - 5 = 8|
|CACHE_INDEX_LEN|5|4. чтобы закодировать индексы 32 блоков нужно log2(32) битов, т.е 5 битов|
|CACHE_OFFSET_LEN|5|5. каждая линия содержит 32 байта и начинается с адреса кратного 32, значит, при определении кэш-линии мы можем опустить последние log2(32) бит информации, т.е 5 бит|
|CACHE_SIZE|4096 Б|3. каждая из 128 кеш-линий cодержит 32 Б, значит размер всего кеша 128 * 32 = 4096 Б|
|CACHE_LINE_SIZE|32 Б|дано|
|CACHE_LINE_COUNT|128|2. каждый из 32 блоков содержит 4 линии(т.к 4-ассоциативность), значит линий 32 * 4 = 128|
|CACHE_SETS|32|дано|

## Моделирование ассемблера

Для моделирования ассемблера нам понадобятся 2 вспомогательных массива. Во-первых, это массив регистров **regs** размером 32, который находится в классе CacheModel. Нужен, чтобы собственно записывать в регистры во время моделирования. А также, нужен массив памяти **Mem** размером MEM_SIZE, для Store и Load команд, который находится в глобальной области видимости(так как часто нам понадобится обращаться к нему из класса блока кэша)

Само моделирование происходит так - мы проходимся по вектору инструкций с помощью условного итератора i, последовательно выполняем нужные инструкции и записываем в регистры. При B. командах i может увеличиться или уменьшиться. При всех Load и Store командах идет запрос в память - а значит, работаем с кешем. Реализован выбор нужного действия с помощью огромного switch-case по id.

 Есть еще 2 важных момента: перед каждой итерацией нулевой регистр обнуляем(так как zero регистр всегда нулевой). А еще, до всего этого в регистр ra искуственно записываем число, равное количеству инструкций умноженному на 4. Это сделано для того, чтобы не зациклиться - в коде задачи на ассемблере мы подразумеваем, что в ra лежит адрес по которому нам нужно вернуться из функции mmul. В нашей же модели там ничего не лежит, из-за чего программа может сломаться и зациклиться. Поэтому исправим это тем, что запишем туда недостижимое число.

 После всего моделирования выгружаем все updated кеш-линии обратно в память(функция **StoreLines**)

 Во время моделирования делали обращения к памяти, а значит к кэшу и в счетчики считали количество попаданий в него, поэтому в зависимости от вводного параметра replacement выводим получившиеся результаты в поток вывода.

## Кеш
### Конфигурация

Сам наш кэш хранится в массиве в классе CacheModel блоками, если точнее, есть два массива для двух разных политик вытеснения, в первом лежат элементы структуры **LRUCacheBlock**, во втором элементы структуры **pLRUCacheBlock**. Оба они размером CACHE_SETS, для нужного блока нужно обратиться по его индексу в этот массив. 

Сами они представляют из себя такую структуру: есть класс-родитель CacheBlock - в нем определены все поля и методы для работы с кэшем, кроме метода **ReplaceLine** и **Reset** - методы, которые работают в зависимости от выбранной политики вытеснения. Поэтому они сделаны виртуальными и переопределены в двух структурах-наследниках, LRUCacheBlock и pLRUCacheBlock.

В полях нашего блока лежит только размер(количество текущих валидных линий) и массив из самих кэш-линий размером CACHE_WAY. Каждая линия представляет из себя структуру CacheLine. Ее состав такой - флаги: updated - чтобы знать, была ли линия обновлена и впоследствии перезаписать память, time - счетчик для политики вытеснения LRU, bit - флаг для политики вытеснения pLRu. После идет тег адреса, а после массив из CACHE_LINE_SIZE байт - та память, которую мы скопировали в эту линию.

### Обращение

Обращение происходит так: во-первых, при Load командах идет запрос на **Read** из памяти, Store на **Write** в память. Это два метода класса CacheModel. Так же заметим, что Load и Store команды могут кидать запрос на несколько байт(1, 2 или 4). Это число **size** принимается как аргумент вышеобьявленных методов.

Оба метода работают так: сначала мы увеличивам счетчик количества запросов и создаем два флага LRUhit и pLRUhit, обозначающих, произошло ли попадание по кэшу для соответственных политик вытеснения. После оправляем size побайтовых запросов в кэш. И если хотябы один из них не попал ко кэшу - считаем, что весь основной запрос не попал по кэшу, так и отображаем в счетчиках.  Их различие в том, что Write еще и записывает в кэш число побайтово в порядке little-endian, а Read в этом же порядке его побайтово читает.

Как именно происходит запрос по байту? Для начала для каждого байта находим адрес adr. Он выглядит так: старшие CACHE_TAG_LEN его битов - это тег адреса, далее идут CACHE_IND_LEN битов означающих индекс блока, оставшиеся младшие CACHE_OFFSET_LEN битов - индекс байта в кеш-линии. Тогда по адресу мы находим его индекс блока и отправляем запрос, обращаясь по этому индексу к массиву блоков.

Запросы по байту - это методы Write и Read структуры CacheBlock. Их общая суть такая: по адресу, который пришел к нам в аргументе, находим его тэг и индекс байта.

 Далее пытаемся найти этот тэг во всех валидных кэш линиях - если удалось, это попадание по байту, передаем true. И обновляем с помощью Reset вспомогательную информацию о линиях для политик вытеснения.

 Если линию не удалось найти, есть две ситуации, в обоих случаях произошел промах по кэшу, передаем false. Если size блока меньше CACHE_WAY, мы подгружаем информацию в свободную линию и увеличиваем size, а если нет, то придется вытеснить одну из линий. Вытесняем ее, и на ее место подгружаем новую информацию. После, обновляем вспомогательную информацию о линиях для политик вытеснения.

Подгружение работает так: вызываем метод LoadLine по индексу линии куда нужно подгрузить и адресу. Метод ставит нужной линии новый тег адреса и загружает в нее CACHE_LINE_LEN байт новой информации из Mem.

Из разницы Write и Read - при Write мы ставим каждой подгруженной/найденной линии updated на true. При Write мы записываем байт по индексу в кеш линию, при Read достаем его из него и возвращаем.
### Политики вытеснения

После того, как мы выбрали линию для вытеснения, мы смотрим на ее флаг updated - если он true, мы должны подгрузить всю информацию из нее в память. Это делается с помощью метода **StoreLine**.

#### LRU

Вытесняется та линия, которая в последний раз была использована давнее всех. Как мы это считаем? У каждой линии есть счетчик time. Когда мы используем линию(попадаем в нее, либо же подгружаем) ставим этот счетчик на ноль, а у остальных линий его инкрементируем. (Это все в методе **Reset**)** Таким образом, нужная линия - линия с самым высоким счетчиком времени. Ее ищем обычным фором, остлеживая максимум, в функции ReplaceLine.

#### bit-pLRU

Вытесняется линия, использованная давно, но не гарантируется, что она была использована давнее всех. Считаем это так: у каждой линии есть флаг bit. Когда используем линию, ставим его в единицу. Если после того, как мы поставили эту единицу, оказалось, что у всех остальных линий тоже единица, все остальные зануляем. (в методе **Reset**) А когда нужно найти линию для вытеснения, просто проходимся по линиям обычным фором в функции ReplaceLine и вытесняем первую линию с нулем во флаге bit.


